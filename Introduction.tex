\chapter{My Dissertation}
\label{chapter:thesis}

\section{Introduction}

Often when developers are faced with a design challenge, they will turn to the whiteboard.  This is typical during the conceptual stages of software design, when no code is in existence yet, but may also happen when a significant code base has already been developed, for instance, to plan new functionality or discuss optimizing a key component. Design sessions at the whiteboard may even arise spontaneously, such as when a developer has to refactor some code or discuss how to best integrate a new feature.

Developers turn to the whiteboard for the flexibility and fluidity that it offers in the design experience [5]. On a whiteboard, developers can freely sketch, branch off to another part of the design problem, return to a previous part, erase some portion of their work, redraw it, and so on, all without the typical restrictions one might find in a traditional software design environment. 
While a preferred medium for design, a significant disadvantage of the whiteboard is that it is a passive medium: it has no facilities that purposefully support the design process. Particularly, whatever is drawn or written remains static and cannot be manipulated, other than drawing over it or erasing it. This is a less than desirable situation, because it is known that software designers often wish to manipulate a design at hand in more advanced ways than merely adding or erasing content [12].

The research community has acknowledged this problem and has contributed many approaches that rely on an electronic whiteboard to provide more advanced support. This support can be divided into two broad categories: (1) approaches that focus on sketch recognition, and (2) approaches that focus on management of sketched content. Approaches in the first category, sketch recognition, attempt to interpret the strokes made by the user to turn them into formal  objects. Early work offered a predefined visual vocabulary for converting sketches into formal objects, such as UML diagrams [4] or user interface mockups [25]. These tools provide feedback to the designer based on the rules of the formal notation they support. Later work made visual vocabularies expandable by users [19] and made using the tools more flexible by delaying interpretation until it was desired by the user [9], sometimes even while retaining a sketchy appearance [7].

Approaches in the second category, sketch management, help organize the potentially many and varied sketched artifacts that may be produced during meetings. Early approaches provided access to a large number of whiteboards through a filmstrip [40], hyperlinks [41], or hierarchical perspectives [32]. Later work automated particular aspects of managing sketches by automatically grouping clusters of sketches in close spatial proximity [31], shrinking sketches when moved to the periphery [18], or using metaphors such as Post-It Notes to organize and relate sketches [23].  
In examining these and other existing sketching tools, it is useful to consider their respective underlying motivations. In so doing, we observe that every sketch tool was designed to support a particular way of working at the whiteboard. For instance, Knight supports designers in refining initial rough sketches into more formal representations [9]. As another example, Flatland supports designers in creating many different diagrams by automatically clustering sketches and adding specialized behaviors to those clusters [31].

In this paper, we define these ways of working as design behaviors. More precisely, we define a design behavior as a recurrent, recognizable set of actions serving a single purpose within a design meeting. Quite a few design behaviors have been identified in the literature, despite the fact that the study of software designers “in action” is still in its infancy. For example, in addition to refinement of sketches and supporting multiple different types of sketches, studies of designers at OOPSLA’s DesignFest have found that software designers improvise their own notations and evolve their diagrams across many canvases [12]. As another example, in-the-field observations at software companies further found that software designers deliberately switch among formalisms and use provisionality to engage in a dialog with incomplete ideas [35]. 

The key insight motivating our research is that software designers do not “operate in” or apply just one behavior for an entire design meeting. Rather, designers interleave design behaviors over the course of a design meeting, switching among them as they see fit to navigate a design problem and its potential solutions. For instance, a designer may first sketch two diagrams and juxtapose them side-by-side to evolve them in parallel, then record patterns of execution in one of the diagrams using an impromptu notation, and thereafter shift to a different aspect of the design problem altogether. The designer fluidly moves between these different design behaviors, typically without an explicit trigger. Shifts are performed intuitively.

During a meeting, it is a natural choice for designers to limit themselves to a single tool to support them. That tool is typically a whiteboard or paper [5], though in some cases it may be a computerized tool like the ones we have described above (e.g., SUMLOW [4], Knight [10], Flatland [31]. In the latter case, the choice of tool determines the behavior or small set of behaviors that are now supported, as designers will seldom move between tools during meetings because of the high cost associated with switching, both in terms of the cognitive burden on the user to switch contexts and in terms of the effort required to import or manually copy the contents. The cost is simply too great and designers, thus, are stuck with support for at best a few of their behaviors as embedded in the tool they happen to be using.

What is desired is a tool that supports a broad range of behaviors and allows developers to fluidly switch among them. Creating such a tool, however, is a non-trivial exercise. Simply picking up functionality from one tool and dropping it in another, and doing this repeatedly to support a multitude of behaviors, leads to tools that are highly disjoint. What does it mean to have available both multiple canvases in a filmstrip and functionality that automatically makes room on the current board?  What does it mean to automatically recognize sketches in tools that also support emergent notations? Existing solutions do not necessarily stack their functionality gracefully, and the approach taken by one tool may collide with the support provided by another.
Our work explicitly addresses the interleaving behaviors that designers exhibit during software design at the whiteboard by taking a step back, examining a collection of behaviors, and contributing a new tool that is designed from the ground up to support this collection of behaviors with a small set of conceptually coherent functionalities.  This proposal lays out our plan for doing so:

•	It introduces and motivates the set of design behaviors that we wish to support.
•	It presents a novel set of features that together support those behaviors.
•	It outlines our plan for assessing the impact of those features on design meetings at the whiteboard. 



%%% Local Variables: ***
%%% mode: latex ***
%%% TeX-master: "thesis.tex" ***
%%% End: ***
